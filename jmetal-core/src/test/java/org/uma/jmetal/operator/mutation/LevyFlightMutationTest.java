package org.uma.jmetal.operator.mutation;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.uma.jmetal.operator.mutation.impl.LevyFlightMutation;
import org.uma.jmetal.solution.doublesolution.DoubleSolution;
import org.uma.jmetal.solution.doublesolution.repairsolution.RepairDoubleSolution;
import org.uma.jmetal.util.bounds.Bounds;
import org.uma.jmetal.util.errorchecking.JMetalException;
import org.uma.jmetal.util.pseudorandom.RandomGenerator;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Unit tests for LevyFlightMutation class
 *
 * Code generated by Claude Sonnet 4
 */
@DisplayName("LevyFlightMutation Tests")
class LevyFlightMutationTest {

  @Mock private DoubleSolution mockSolution;

  @Mock private RepairDoubleSolution mockSolutionRepair;

  @Mock private RandomGenerator<Double> mockRandomGenerator;

  @Mock private Bounds<Double> mockBounds;

  private LevyFlightMutation levyMutation;

  @BeforeEach
  void setUp() {
    MockitoAnnotations.openMocks(this);
  }

  @Nested
  @DisplayName("Constructor Tests")
  class ConstructorTests {

    @Test
    @DisplayName("Default constructor should set default values")
    void testDefaultConstructor() {
      LevyFlightMutation mutation = new LevyFlightMutation();

      assertEquals(0.01, mutation.mutationProbability(), 1e-10);
      assertEquals(1.5, mutation.beta(), 1e-10);
      assertEquals(0.01, mutation.stepSize(), 1e-10);
      assertNotNull(mutation.solutionRepair());
    }

    @Test
    @DisplayName("Constructor with valid parameters should succeed")
    void testConstructorWithValidParameters() {
      LevyFlightMutation mutation = new LevyFlightMutation(0.1, 1.8, 0.05);

      assertEquals(0.1, mutation.mutationProbability(), 1e-10);
      assertEquals(1.8, mutation.beta(), 1e-10);
      assertEquals(0.05, mutation.stepSize(), 1e-10);
    }

    @Test
    @DisplayName("Constructor with custom repair strategy should succeed")
    void testConstructorWithCustomRepair() {
      LevyFlightMutation mutation = new LevyFlightMutation(0.1, 1.5, 0.01, mockSolutionRepair);

      assertEquals(0.1, mutation.mutationProbability(), 1e-10);
      assertEquals(1.5, mutation.beta(), 1e-10);
      assertEquals(0.01, mutation.stepSize(), 1e-10);
      assertEquals(mockSolutionRepair, mutation.solutionRepair());
    }

    @Test
    @DisplayName("Constructor with all parameters should succeed")
    void testConstructorWithAllParameters() {
      LevyFlightMutation mutation =
          new LevyFlightMutation(0.2, 1.3, 0.08, mockSolutionRepair, mockRandomGenerator);

      assertEquals(0.2, mutation.mutationProbability(), 1e-10);
      assertEquals(1.3, mutation.beta(), 1e-10);
      assertEquals(0.08, mutation.stepSize(), 1e-10);
      assertEquals(mockSolutionRepair, mutation.solutionRepair());
    }

    @ParameterizedTest
    @ValueSource(doubles = {-0.1, -1.0, 1.1, 2.0})
    @DisplayName("Constructor should throw exception for invalid mutation probability")
    void testConstructorWithInvalidMutationProbability(double invalidProbability) {
      assertThrows(
          JMetalException.class, () -> new LevyFlightMutation(invalidProbability, 1.5, 0.01));
    }

    @ParameterizedTest
    @ValueSource(doubles = {0.5, 1.0, 2.1, 3.0})
    @DisplayName("Constructor should throw exception for invalid beta parameter")
    void testConstructorWithInvalidBeta(double invalidBeta) {
      assertThrows(JMetalException.class, () -> new LevyFlightMutation(0.1, invalidBeta, 0.01));
    }

    @ParameterizedTest
    @ValueSource(doubles = {0.0, -0.1, -1.0})
    @DisplayName("Constructor should throw exception for invalid step size")
    void testConstructorWithInvalidStepSize(double invalidStepSize) {
      assertThrows(JMetalException.class, () -> new LevyFlightMutation(0.1, 1.5, invalidStepSize));
    }
  }

  @Nested
  @DisplayName("Execution Tests")
  class ExecutionTests {

    @BeforeEach
    void setUp() {
      levyMutation =
          new LevyFlightMutation(0.1, 1.5, 0.01, mockSolutionRepair, mockRandomGenerator);
    }

    @Test
    @DisplayName("Execute should throw exception for null solution")
    void testExecuteWithNullSolution() {
      assertThrows(JMetalException.class, () -> levyMutation.execute(null));
    }

    @Test
    @DisplayName("Execute should return the same solution instance")
    void testExecuteReturnsSameSolution() {
      setupMockSolution(3, List.of(1.0, 2.0, 3.0));
      when(mockRandomGenerator.getRandomValue()).thenReturn(0.5); // Above mutation probability

      DoubleSolution result = levyMutation.execute(mockSolution);

      assertSame(mockSolution, result);
    }

    @Test
    @DisplayName("Execute should not mutate when random value exceeds probability")
    void testExecuteNoMutationWhenRandomValueHigh() {
      List<Double> variables = new ArrayList<>(List.of(1.0, 2.0));
      setupMockSolution(2, variables);
      when(mockRandomGenerator.getRandomValue()).thenReturn(0.5); // Above 0.1 probability

      levyMutation.execute(mockSolution);

      // Verify values remain unchanged
      assertEquals(1.0, variables.get(0), 1e-10);
      assertEquals(2.0, variables.get(1), 1e-10);
      // Verify repair was never called
      verify(mockSolutionRepair, never())
          .repairSolutionVariableValue(anyDouble(), anyDouble(), anyDouble());
    }

    @Test
    @DisplayName("Execute should mutate when random value is below probability")
    void testExecuteMutationWhenRandomValueLow() {
      List<Double> variables = new ArrayList<>(List.of(1.5));
      setupMockSolution(1, variables);
      when(mockRandomGenerator.getRandomValue()).thenReturn(0.05); // Below 0.1 probability
      when(mockSolutionRepair.repairSolutionVariableValue(anyDouble(), anyDouble(), anyDouble()))
          .thenReturn(1.6);

      levyMutation.execute(mockSolution);

      // Verify the repair method was called
      verify(mockSolutionRepair, times(1))
          .repairSolutionVariableValue(anyDouble(), eq(0.0), eq(2.0));
      // Verify the variable was updated with the repaired value
      assertEquals(1.6, variables.get(0), 1e-10);
    }

    @Test
    @DisplayName("Execute should use solution repair for out-of-bounds values")
    void testExecuteUsesSolutionRepair() {
      List<Double> variables = new ArrayList<>(List.of(1.0));
      setupMockSolution(1, variables);
      when(mockRandomGenerator.getRandomValue()).thenReturn(0.05);
      when(mockSolutionRepair.repairSolutionVariableValue(anyDouble(), eq(0.0), eq(2.0)))
          .thenReturn(1.5);

      levyMutation.execute(mockSolution);

      verify(mockSolutionRepair, times(1))
          .repairSolutionVariableValue(anyDouble(), eq(0.0), eq(2.0));
      assertEquals(1.5, variables.get(0), 1e-10);
    }

    @Test
    @DisplayName("Execute should handle multiple variables")
    void testExecuteWithMultipleVariables() {
      List<Double> variables = new ArrayList<>(List.of(1.0, 2.0, 3.0));
      setupMockSolution(3, variables);
      when(mockRandomGenerator.getRandomValue()).thenReturn(0.05); // Always mutate
      when(mockSolutionRepair.repairSolutionVariableValue(anyDouble(), anyDouble(), anyDouble()))
          .thenReturn(1.1, 2.1, 3.1);

      levyMutation.execute(mockSolution);

      // Verify repair was called for each variable
      verify(mockSolutionRepair, times(3))
          .repairSolutionVariableValue(anyDouble(), eq(0.0), eq(2.0));
      // Verify all variables were updated
      assertEquals(1.1, variables.get(0), 1e-10);
      assertEquals(2.1, variables.get(1), 1e-10);
      assertEquals(3.1, variables.get(2), 1e-10);
    }
  }

  @Nested
  @DisplayName("Parameter Getter and Setter Tests")
  class ParameterTests {

    @BeforeEach
    void setUp() {
      levyMutation = new LevyFlightMutation();
    }

    @Test
    @DisplayName("Should get and set mutation probability correctly")
    void testMutationProbabilityGetterSetter() {
      assertEquals(0.01, levyMutation.mutationProbability(), 1e-10);

      levyMutation.mutationProbability(0.5);
      assertEquals(0.5, levyMutation.mutationProbability(), 1e-10);
    }

    @ParameterizedTest
    @ValueSource(doubles = {-0.1, 1.1, 2.0})
    @DisplayName("Should throw exception for invalid mutation probability")
    void testSetInvalidMutationProbability(double invalidProbability) {
      assertThrows(
          JMetalException.class, () -> levyMutation.mutationProbability(invalidProbability));
    }

    @Test
    @DisplayName("Should get and set beta correctly")
    void testBetaGetterSetter() {
      assertEquals(1.5, levyMutation.beta(), 1e-10);

      levyMutation.beta(1.8);
      assertEquals(1.8, levyMutation.beta(), 1e-10);
    }

    @ParameterizedTest
    @ValueSource(doubles = {1.0, 2.1, 3.0})
    @DisplayName("Should throw exception for invalid beta parameter")
    void testSetInvalidBeta(double invalidBeta) {
      assertThrows(JMetalException.class, () -> levyMutation.beta(invalidBeta));
    }

    @Test
    @DisplayName("Should get and set step size correctly")
    void testStepSizeGetterSetter() {
      assertEquals(0.01, levyMutation.stepSize(), 1e-10);

      levyMutation.stepSize(0.05);
      assertEquals(0.05, levyMutation.stepSize(), 1e-10);
    }

    @ParameterizedTest
    @ValueSource(doubles = {0.0, -0.1, -1.0})
    @DisplayName("Should throw exception for invalid step size")
    void testSetInvalidStepSize(double invalidStepSize) {
      assertThrows(JMetalException.class, () -> levyMutation.stepSize(invalidStepSize));
    }

    @Test
    @DisplayName("Should get and set solution repair correctly")
    void testSolutionRepairGetterSetter() {
      assertNotNull(levyMutation.solutionRepair());

      levyMutation.solutionRepair(mockSolutionRepair);
      assertEquals(mockSolutionRepair, levyMutation.solutionRepair());
    }
  }

  @Nested
  @DisplayName("Boundary Value Tests")
  class BoundaryValueTests {

    @Test
    @DisplayName("Should handle minimum valid beta value")
    void testMinimumValidBeta() {
      assertDoesNotThrow(() -> new LevyFlightMutation(0.1, 1.0001, 0.01));
    }

    @Test
    @DisplayName("Should handle maximum valid beta value")
    void testMaximumValidBeta() {
      assertDoesNotThrow(() -> new LevyFlightMutation(0.1, 2.0, 0.01));
    }

    @Test
    @DisplayName("Should handle minimum valid mutation probability")
    void testMinimumValidMutationProbability() {
      assertDoesNotThrow(() -> new LevyFlightMutation(0.0, 1.5, 0.01));
    }

    @Test
    @DisplayName("Should handle maximum valid mutation probability")
    void testMaximumValidMutationProbability() {
      assertDoesNotThrow(() -> new LevyFlightMutation(1.0, 1.5, 0.01));
    }

    @Test
    @DisplayName("Should handle very small step size")
    void testVerySmallStepSize() {
      assertDoesNotThrow(() -> new LevyFlightMutation(0.1, 1.5, 1e-10));
    }

    @Test
    @DisplayName("Should handle very large step size")
    void testVeryLargeStepSize() {
      assertDoesNotThrow(() -> new LevyFlightMutation(0.1, 1.5, 1000.0));
    }
  }

  @Nested
  @DisplayName("Statistical Tests")
  class StatisticalTests {

    @Test
    @DisplayName("Should generate different Levy steps")
    void testLevyStepGeneration() {
      // Use real random generator for this test
      LevyFlightMutation mutation = new LevyFlightMutation(1.0, 1.5, 0.01);
      List<Double> variables =
          new ArrayList<>(List.of(1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0));
      setupMockSolution(10, variables);

      List<Double> capturedValues = new ArrayList<>();
      doAnswer(
              invocation -> {
                capturedValues.add(invocation.getArgument(0));
                return invocation.getArgument(0);
              })
          .when(mockSolutionRepair)
          .repairSolutionVariableValue(anyDouble(), anyDouble(), anyDouble());

      mutation.execute(mockSolution);

      // Check that we have some variation in the generated values
      assertTrue(capturedValues.size() > 0);
      // Values should not all be the same (very unlikely with real random generation)
      boolean hasVariation = false;
      for (int i = 1; i < capturedValues.size(); i++) {
        if (!capturedValues.get(i).equals(capturedValues.get(0))) {
          hasVariation = true;
          break;
        }
      }
      // Note: This test might occasionally fail due to randomness, but it's very unlikely
      assertTrue(hasVariation, "Generated values should show variation");
    }

    @Test
    @DisplayName("Should respect mutation probability")
    void testMutationProbabilityRespected() {
      // Test with 0% mutation probability
      LevyFlightMutation mutation = new LevyFlightMutation(0.0, 1.5, 0.01);
      List<Double> variables = new ArrayList<>(List.of(1.0, 2.0, 3.0, 4.0, 5.0));
      setupMockSolution(5, variables);

      mutation.execute(mockSolution);

      // Should not mutate any variables - verify values remain unchanged
      assertEquals(1.0, variables.get(0), 1e-10);
      assertEquals(2.0, variables.get(1), 1e-10);
      assertEquals(3.0, variables.get(2), 1e-10);
      assertEquals(4.0, variables.get(3), 1e-10);
      assertEquals(5.0, variables.get(4), 1e-10);

      // Verify repair was never called
      verify(mockSolutionRepair, never())
          .repairSolutionVariableValue(anyDouble(), anyDouble(), anyDouble());
    }
  }

  @Nested
  @DisplayName("ToString Tests")
  class ToStringTests {

    @Test
    @DisplayName("Should return correct string representation")
    void testToString() {
      LevyFlightMutation mutation = new LevyFlightMutation(0.1, 1.5, 0.01);
      String result = mutation.toString();

      assertTrue(result.contains("LevyFlightMutation"));
      assertTrue(result.contains("mutationProbability=0.1"));
      assertTrue(result.contains("beta=1.5"));
      assertTrue(result.contains("stepSize=0.01"));
    }
  }

  /** Helper method to set up mock solution with specified variables */
  private void setupMockSolution(int numVariables, List<Double> values) {
    List<Double> variables = new ArrayList<>(values);
    when(mockSolution.variables()).thenReturn(variables);

    for (int i = 0; i < numVariables; i++) {
      when(mockSolution.getBounds(i)).thenReturn(mockBounds);
      when(mockBounds.getLowerBound()).thenReturn(0.0);
      when(mockBounds.getUpperBound()).thenReturn(2.0);
    }
  }
}
